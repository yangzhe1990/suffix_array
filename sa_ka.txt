不加编译开关：

知道选择是S或者L的情况下一边写orig_pos一边插桶耗时0.19
知道选择是S或者L的情况下分别写orig_pos和插桶耗时0.233

不知道选择是S或L的情况下都写入orig_pos最后将选取的插桶耗时0.267
不知道选择是S或L的情况下先计算是S还是L再一边写orig_pos一边插桶耗时0.3

O2开关：

都写入再选取0.125
先计算是谁再一边写入一边插桶0.105

================================================

LSSSSSSSLSLSSLLLSLL

L比较少的情况，由于最后一个是L，L的子字符串实际上是L的总数 - 1。最后一个L字母不需要参与递归排序，直接在递归排序完成后率先插入就好了。// FIXME 目前实现的是所有L一起排序的情况。
S比较少的情况，要排序的子字符串数目是S的总数。

================

 |LLLSSS|
  .
扫描到L的时候，往回更新一定是修改之前的bucket，往后更新一定是修改当前或者之后的bucket，因此last_deleg在此情况下不互相干扰。bucket_p也可以复用，

 |LLLSSS|
      .
扫描到S的时候，往回更新有可能修改当前的bucket。而往后更新一定是修改之后的bucket，因此last_deleg在此情况下不互相干扰。bucket_p也可以复用，而且正好在刚从L转换S的时候，bucket_p的位置在第一个S处。

干扰的问题之外，在向后更新使用完某个bucket的last_deleg后，它的值是小于这个bucket的最后一个L的位置的。在向回更新时候，last_deleg的值一定是大于这个bucket的第一个S的位置的。但是相等的判定是，如果last_deleg == equal_deleg，认为相等。因此可以相安无事。

===============================

L模式：

L是正着插入桶的。而初始化时，同一个桶内，应当下标大的靠前。所以插入桶时应该倒着排序。

用L更新S时，工作方式不需要变化。在向后更新部分，L是按照倒着的顺序被放进排序子串的，这其实也跟S模式对称。

在求新pattern时，倒着扫描也可以，因为new_alphabet_size在之前就会计算好。而orig_pos应该是顺序的。在插入桶时要注意反着存orig_pos。

equal属性（MASK_N）按照从后向前的方式理解，如果i有equal属性，则i - 1 == i。
